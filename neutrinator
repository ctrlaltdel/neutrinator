#!/usr/bin/env python

import os
import sys
import re
import argparse
import logging
from pprint import pprint, pformat
from subprocess import check_output
from novaclient.v1_1 import client as nova_client
from neutronclient.v2_0 import client as neutron_client

domain = None
compute_node = None

def on_compute(cmd):
  global compute_node
  return ssh(compute_node, cmd)

def pindent(text, indentation=0):
  for line in text.split('\n'):
    print ' ' * indentation + line

def tcpdump_dhcp(host, interface, mac):
  mac_filter = '0x' + mac[6:].replace(':', '')
  cmd = 'tcpdump -c 1 -i %s -vvv -s 1500 "((port 67 or port 68) and (udp[38:4] = %s))"' % (interface, mac_filter)
  logging.debug(cmd)
  #cmd = 'tcpdump -c 1 -i %s -vvv -s 1500 "(port 67 or port 68)"' % (interface)
  return check_output(['ssh', 'root@%s' % host, cmd])

def ssh(host, cmd):
  logging.debug('ssh(%s, %s)' % (host, cmd))
  result = check_output(['ssh', 'root@%s' % host, cmd])
  logging.debug(result)
  return result

def fqdn(nova, host):
  global domain

  if not domain:
    raise Exception('No domain detected')

  # HACK: hostname from neutron API is not fully qualified anymore
  if not '.' in host:
    fqdn = host + '.' + domain
  else:
    fqdn = host

  return fqdn

def get_bridge_tag(node, interface):
  bridge = ssh(node, 'ovs-vsctl iface-to-br %s' % interface).strip()
  logging.debug('bridge: %s', bridge)
  tag = ssh(node, 'ovs-vsctl get port %s tag' % interface).strip()
  logging.debug('tag: %s', tag)

  return bridge, tag

def get_ovs_path(node, interface):
  path = []

  bridge, tag = get_bridge_tag(node, interface)
  path.append((node, '%s VLAN %s' % (bridge, tag)))

  bridge, actions = find_outgoing_bridge(node, bridge, tag)
  path.append((node, '%s %s' % (bridge, actions)))

  return path

def get_router(neutron, network_id):
  router_path = []

  try:
    router_port = neutron.list_ports(network_id=network_id, device_owner='network:router_interface')['ports'][0]
  except:
    logging.warn('No virtual router found')
    return None, None

  logging.debug(router_port)

  router_id = router_port['device_id']

  l3_node = neutron.list_l3_agent_hosting_routers(router_id)['agents'][0]['host']
  l3_node = fqdn(nova, l3_node)

  qr = ssh(l3_node, "ip netns exec qrouter-%s ip link ls | grep qr-%s | awk '{ print $2; }' | cut -d: -f1" % (router_id, router_port['id'][:11])).strip()
  qg = ssh(l3_node, "ip netns exec qrouter-%s ip link ls | grep qg | awk '{ print $2; }' | cut -d: -f1" % router_id).strip()

  router_path += reversed(get_ovs_path(l3_node, qr))
  router_path.append((l3_node, qr, router_port['status']))
  router_path.append((l3_node, qg, router_port['status']))
  router_path += get_ovs_path(l3_node, qg)

  return router_path, router_id

def get_dhcp_path(neutron, network_id):
  node = neutron.list_dhcp_agent_hosting_networks(network_id)['agents'][0]['host']
  node = fqdn(nova, node)

  dhcp_ports = neutron.list_ports(network_id=network_id, device_owner='network:dhcp')['ports']
  logging.debug(dhcp_ports)

  if len(dhcp_ports) != 1:
    raise Exception('no support for multiple DHCP servers')

  logging.debug('Routing table:')
  logging.debug((ssh(node, 'ip netns exec qdhcp-%s ip ro ls' % (network_id)), 2))

  dhcp_interface = ssh(node, "ip netns exec qdhcp-%s ip link ls | grep tap | awk '{ print $2; }' | cut -d: -f1" % network_id).strip()

  path = []
  path += reversed(get_ovs_path(node, dhcp_interface))
  path.append((node, dhcp_interface, dhcp_ports[0]['status']))

  return path

def find_outgoing_bridge(node, bridge, tag):
  """
  Try to find out how a given vlan id on the integration bridge is
  connected to the external world.
  """

  # FIXME: Is it possible for two different bridges to use same tag?
  bridges = ssh(node, 'ovs-vsctl list-br').split('\n')[0:-1]

  logging.debug('briges connected to the integration bridge: %s' % repr(bridges))

  # FIXME
  if tag == '[]': # No VLAN tagging
    return 'TODO', ''

  for bridge in bridges:
    flow = ssh(node, 'ovs-ofctl dump-flows %s | grep dl_vlan=%s || true' % (bridge, tag))
    logging.debug('flow: %s', repr(flow))

    if flow != '':
      actions = re.findall('(actions=[^ ]+)', flow)
      if actions:
        return bridge, actions[0].strip()

  raise Exception('Outgoing bridge not found, please report a bug')

def get_instance_path(nova, neutron, instance_id):
  global compute_node

  path = []

  instance = nova.servers.get(instance_id)
  
  compute_node = getattr(instance, 'OS-EXT-SRV-ATTR:hypervisor_hostname')

  global domain
  domain = '.'.join(compute_node.split('.')[1:])

  path.append((instance.name, 'eth0'))
  
  logging.debug('Instance ID: %s, Name: %s' % (instance.id, instance.name))
  
  logging.debug('Console log')
  for line in nova.servers.get_console_output(instance_id).split('\n'):
    if line.startswith('ci-info:'):
      logging.debug(line)
  
  ports = neutron.list_ports(device_id=instance_id)['ports']

  if len(ports) > 1:
    raise Exception("This program doesn't currently supports multiple interfaces connected to a single VM")
  
  port = ports[0]

  logging.debug('Port: ' + port['id'])

  if len(port['fixed_ips']) > 1:
    raise Exception("This program doesn't currently support multiple IP addresses per interface")

  fixed_ip = port['fixed_ips'][0]
  logging.debug('IP: ' + fixed_ip['ip_address'])
  
  subnet = fixed_ip['subnet_id']
  logging.debug('Subnet: ' + subnet)
  
  for line in pformat(neutron.show_subnet(subnet)).split('\n'):
    logging.debug(line)

  network_id = neutron.show_subnet(subnet)['subnet']['network_id']

  if len(neutron.list_dhcp_agent_hosting_networks(network_id)['agents']) != 1:
    raise Exception("This program supports only a single DHCP agent")

  logging.debug('Libvirt domain info:')
  logging.debug(on_compute('virsh dominfo %s' % getattr(instance, 'OS-EXT-SRV-ATTR:instance_name')))
  
  logging.debug('Libvirt domain interfaces list:')
  domiflist = on_compute('virsh domiflist %s' % getattr(instance, 'OS-EXT-SRV-ATTR:instance_name'))
  logging.debug(domiflist)
  
  libvirt_interfaces = domiflist.split('\n')[2:-2]

  if len(libvirt_interfaces) != 1:
    raise Exception('This program supports only a single libvirt interface per vm')

  intf = libvirt_interfaces[0]
  (interface, type, source, model, mac) = re.split('\s+', intf)

  path.append((
    compute_node,
    interface,
    'STATUS: %s, MAC: %s' % (port['status'], port['mac_address'])
  ))
  
  #print 'tcpdump on %s' % interface
  #print on_compute('tcpdump -c 5 -ni %s' % interface)
  
  path.append((compute_node, source))
  
  #print 'tcpdump on %s' % source
  #print on_compute('tcpdump -c 5 -ni %s' % source)

  brctl_show = on_compute('brctl show %s' % source)
  qvb = re.findall('(qvb.+)', brctl_show)[0]
  logging.debug('qvb: %s', qvb)

  path.append((compute_node, qvb))

  # FIXME: is there a better way to find if qvo interface actually
  # exists and is correctly configured?
  qvo = qvb.replace('qvb', 'qvo')
  logging.debug('qvo: %s', qvo)

  path += get_ovs_path(compute_node, qvo)

  logging.debug('KVM process:')
  logging.debug(on_compute('ps ax | grep [%s]%s' % (instance_id[0], instance_id[1:])))
 
  #print tcpdump_dhcp(compute_node, interface, mac)

  return network_id, path

def init_nova():
  return nova_client.Client(
    os.environ['OS_USERNAME'],
    os.environ['OS_PASSWORD'],
    os.environ['OS_TENANT_NAME'],
    os.environ['OS_AUTH_URL'],
    service_type="compute")

def init_neutron():
  return neutron_client.Client(
    username=os.environ['OS_USERNAME'],
    password=os.environ['OS_PASSWORD'],
    tenant_name=os.environ['OS_TENANT_NAME'],
    auth_url=os.environ['OS_AUTH_URL'])

class Instance():
  ''' This class is a wrapper around novaclient's Server class '''
  __instance = None

  def __init__(self, id):
    self.__instance = nova.servers.get(id)
    self.__ports = neutron.list_ports(device_id=id)['ports']

    self.id = id
    self.name = self.__instance.name
    self.compute_node = getattr(self.__instance, 'OS-EXT-SRV-ATTR:hypervisor_hostname')
    self.tenant_id = self.__instance.tenant_id

  def list_interfaces(self):
    return map(lambda p: p['id'], self.__ports)

  def get_interfaces_ips(self, interface):
    port = filter(lambda p: p['id'] == interface, self.__ports)[0]
    logging.debug(port)
    return [i['ip_address'] for i in port['fixed_ips']]

  def get_firewall(self):
    return Firewall(self.tenant_id)

class Interface():
  pass

class Firewall():
  def __init__(self, tenant_id):
    self.tenant_id = tenant_id

    try:
      firewalls = neutron.list_firewalls(tenant_id=tenant_id)['firewalls']
      logging.debug('Firewalls: %s' % firewalls)
    except KeyError:
      self.id = None

    if len(firewalls) == 0:
      self.id = None
      logging.debug('No firewall found')
    elif len(firewalls) == 1:
      self.id = firewall[0]['id']
      logging.debug('One firewall found: %s' % self.id)
    else:
      raise Exception('Multiple firewalls found, this is weird')

  def get_rules(self):
    rules = []

    for policy in neutron.list_firewall_policies(firewall_id=self.id)['firewall_policies']:
      for rule in neutron.list_firewall_rules(firewall_policy_id=policy['id'])['firewall_rules']:
        rules.append((
          str(rule[item]) for item in
            ('name', 'protocol', 'source_ip_address', 'source_port',
            'destination_ip_address', 'destination_port', 'action',
            'enabled')
        ))

    return rules

if __name__ == '__main__':
  parser = argparse.ArgumentParser(description='''Neutrinator is a tool
  which helps operators to see through the OpenStack Neutron virtual
  network maze''')
  
  parser.add_argument('--debug', '-d', action='store_true')

  parser.add_argument('instance_id')
  args = parser.parse_args()

  if args.debug:
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)

  nova = init_nova()  
  neutron = init_neutron()

  instance = Instance(args.instance_id)
  network_id, compute_path = get_instance_path(nova, neutron, args.instance_id)
  dhcp_path = get_dhcp_path(neutron, network_id)
  router_path, router_id = get_router(neutron, network_id)

  print
  print '== INSTANCE DETAILS =='
  print

  print 'Instance ID:   ', instance.id
  print 'Instance Name: ', instance.name
  print 'Compute node:  ', instance.compute_node
  print 'Interfaces: '
  for interface in instance.list_interfaces():
    pindent(interface + ' ' + ' '.join(instance.get_interfaces_ips(interface)), 2)
  

  for interface in instance.list_interfaces():
    print
    print '== L2 PATH (%s) ==' % interface
    print
  
    print 'COMPUTE:'
  # http://openstack.redhat.com/Networking_in_too_much_detail
    pindent('\n'.join(('\t'.join(a) for a in compute_path)), 2)
    print
  
    print 'DHCP:'
    pindent('\n'.join(('\t'.join(a) for a in dhcp_path)), 2)
    print
  
    if router_id:
      print 'L3 ROUTER:'
      print
      pindent('Router ID: %s' % router_id, 2)
      print
      pindent('\n'.join(('\t'.join(a) for a in router_path)), 2)
      print

  firewall = instance.get_firewall()
  print firewall
  if firewall.id:
    print '== FWaaS =='
    print
    pindent('Firewall ID: %s' % firewall.id, 2)
    print
    pindent('\n'.join(('\t'.join(a) for a in firewall.get_rules())), 2)
