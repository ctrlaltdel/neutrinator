#!/usr/bin/env python

import os
import sys
import re
import argparse
import logging
from pprint import pprint, pformat
from subprocess import check_output
from novaclient.v1_1 import client as nova_client
from neutronclient.v2_0 import client as neutron_client

domain = None

def pindent(text, indentation=0):
  for line in text.split('\n'):
    print ' ' * indentation + line

def tcpdump_dhcp(host, interface, mac):
  mac_filter = '0x' + mac[6:].replace(':', '')
  cmd = 'tcpdump -c 1 -i %s -vvv -s 1500 "((port 67 or port 68) and (udp[38:4] = %s))"' % (interface, mac_filter)
  logging.debug(cmd)
  #cmd = 'tcpdump -c 1 -i %s -vvv -s 1500 "(port 67 or port 68)"' % (interface)
  return check_output(['ssh', 'root@%s' % host, cmd])

def ssh(host, cmd):
  logging.debug('ssh(%s, %s)' % (host, cmd))
  result = check_output(['ssh', 'root@%s' % host, cmd])
  logging.debug(result)
  return result

def fqdn(nova, host):
  global domain

  if not domain:
    raise Exception('No domain detected')

  # HACK: hostname from neutron API is not fully qualified anymore
  if not '.' in host:
    fqdn = host + '.' + domain
  else:
    fqdn = host

  return fqdn

def get_router(neutron, network_id):
  router_path = []

  try:
    router_port = neutron.list_ports(network_id=network_id, device_owner='network:router_interface')['ports'][0]
    logging.debug(router_port)

    router_id = router_port['device_id']

    l3_node = neutron.list_l3_agent_hosting_routers(router_id)['agents'][0]['host']
    l3_node = fqdn(nova, l3_node)

    router_path.append((l3_node, 'TODO'))

    qr = ssh(l3_node, "ip netns exec qrouter-%s ip link ls | grep qr-%s | awk '{ print $2; }' | cut -d: -f1" % (router_id, router_port['id'][:11])).strip()
    qg = ssh(l3_node, "ip netns exec qrouter-%s ip link ls | grep qg | awk '{ print $2; }' | cut -d: -f1" % router_id).strip()

    router_path.append((l3_node, qr, router_port['status']))
    router_path.append((l3_node, qg, router_port['status']))

    bridge = ssh(l3_node, 'ovs-vsctl port-to-br %s' % qg).strip()
    tag = ssh(l3_node, 'ovs-vsctl get port %s tag' % qg).strip()

    router_path.append((l3_node, '%s VLAN %s' % (bridge, tag)))

    external_port = ssh(l3_node, "ovs-vsctl list-ports %s | egrep -v 'qg-|phy-'" % bridge).strip()

    router_path.append((l3_node, external_port))
  except:
    pass

  return router_path, router_id

def get_dhcp_path(neutron, network_id):
  path = []

  node = neutron.list_dhcp_agent_hosting_networks(network_id)['agents'][0]['host']
  node = fqdn(nova, node)

  path.append((node, 'TODO'))

  dhcp_ports = neutron.list_ports(network_id=network_id, device_owner='network:dhcp')['ports']
  logging.debug(dhcp_ports)

  if len(dhcp_ports) != 1:
    raise Exception('no support for multiple DHCP servers')

  logging.debug('Routing table:')
  logging.debug((ssh(node, 'ip netns exec qdhcp-%s ip ro ls' % (network_id)), 2))

  dhcp_interface = ssh(node, "ip netns exec qdhcp-%s ip link ls | grep tap | awk '{ print $2; }' | cut -d: -f1" % network_id).strip()

  path.append((node, dhcp_interface, dhcp_ports[0]['status']))

  return path

def get_instance_path(nova, neutron, instance_id):
  def on_compute(cmd):
    return ssh(compute_node, cmd)

  path = []

  instance = nova.servers.get(instance_id)
  
  compute_node = getattr(instance, 'OS-EXT-SRV-ATTR:hypervisor_hostname')

  global domain
  domain = '.'.join(compute_node.split('.')[1:])

  path.append((instance.name, 'eth0'))
  
  logging.debug('Instance ID: %s, Name: %s' % (instance.id, instance.name))
  
  logging.debug('Console log')
  for line in nova.servers.get_console_output(instance_id).split('\n'):
    if line.startswith('ci-info:'):
      logging.debug(line)
  
  ports = neutron.list_ports(device_id=instance_id)['ports']

  if len(ports) > 1:
    raise Exception("This program doesn't currently supports multiple interfaces connected to a single VM")
  
  port = ports[0]

  logging.debug('Port: ' + port['id'])

  if len(port['fixed_ips']) > 1:
    raise Exception("This program doesn't currently support multiple IP addresses per interface")

  fixed_ip = port['fixed_ips'][0]
  logging.debug('IP: ' + fixed_ip['ip_address'])
  
  subnet = fixed_ip['subnet_id']
  logging.debug('Subnet: ' + subnet)
  
  for line in pformat(neutron.show_subnet(subnet)).split('\n'):
    logging.debug(line)

  network_id = neutron.show_subnet(subnet)['subnet']['network_id']

  if len(neutron.list_dhcp_agent_hosting_networks(network_id)['agents']) != 1:
    raise Exception("This program supports only a single DHCP agent")

  print
  print '== COMPUTE NODE =='
  print
  
  print 'Compute node: ', compute_node
  
 
  logging.debug('Libvirt domain info:')
  logging.debug(on_compute('virsh dominfo %s' % getattr(instance, 'OS-EXT-SRV-ATTR:instance_name')))
  
  logging.debug('Libvirt domain interfaces list:')
  domiflist = on_compute('virsh domiflist %s' % getattr(instance, 'OS-EXT-SRV-ATTR:instance_name'))
  logging.debug(domiflist)
  
  libvirt_interfaces = domiflist.split('\n')[2:-2]

  if len(libvirt_interfaces) != 1:
    raise Exception('This program supports only a single libvirt interface per vm')

  intf = libvirt_interfaces[0]
  (interface, type, source, model, mac) = re.split('\s+', intf)

  path.append((
    compute_node,
    interface,
    'STATUS: %s, MAC: %s' % (port['status'], port['mac_address'])
  ))
  
  #print 'tcpdump on %s' % interface
  #print on_compute('tcpdump -c 5 -ni %s' % interface)
  
  path.append((compute_node, source))
  
  #print 'tcpdump on %s' % source
  #print on_compute('tcpdump -c 5 -ni %s' % source)

  brctl_show = on_compute('brctl show %s' % source)
  qvb = re.findall('(qvb.+)', brctl_show)[0]
  logging.debug('qvb: %s', qvb)

  path.append((compute_node, qvb))

  # FIXME: is there a better way to find if qvo interface actually
  # exists and is correctly configured?
  qvo = qvb.replace('qvb', 'qvo')
  logging.debug('qvo: %s', qvo)

  path.append((compute_node, qvo))

  bridge = on_compute('ovs-vsctl port-to-br %s' % qvo).strip()
  logging.debug('bridge: %s', bridge)
  tag = on_compute('ovs-vsctl get port %s tag' % qvo).strip()
  logging.debug('tag: %s', tag)

  path.append((compute_node, '%s VLAN %s' % (bridge, tag)))

  # Find out where the integration bridge is connected to
  bridges = on_compute('ovs-vsctl list-ifaces %s | egrep "^int-" | sed "s/^int-//"' % bridge_int).split('\n')[0:-1]

  logging.debug('briges connected to the integration bridge: %s' % repr(bridges))

  for bridge in bridges:
    flow = on_compute('ovs-ofctl dump-flows %s | grep dl_vlan=%s || true' % (bridge, tag))
    logging.debug('flow: %s', repr(flow))

    if flow != '':
      actions = re.findall('(actions=[^ ]+)', flow)
      if actions:
        path.append((compute_node, '%s %s' % (bridge, actions[0].strip())))

  logging.debug('KVM process:')
  logging.debug(on_compute('ps ax | grep [%s]%s' % (instance_id[0], instance_id[1:])))
 
  #print tcpdump_dhcp(compute_node, interface, mac)

  return network_id, path

def init_nova():
  return nova_client.Client(
    os.environ['OS_USERNAME'],
    os.environ['OS_PASSWORD'],
    os.environ['OS_TENANT_NAME'],
    os.environ['OS_AUTH_URL'],
    service_type="compute")

def init_neutron():
  return neutron_client.Client(
    username=os.environ['OS_USERNAME'],
    password=os.environ['OS_PASSWORD'],
    tenant_name=os.environ['OS_TENANT_NAME'],
    auth_url=os.environ['OS_AUTH_URL'])


if __name__ == '__main__':
  parser = argparse.ArgumentParser(description='Neutrinator is a tool which helps you seeing through the virtual network maze')
  parser.add_argument('--debug', '-d', action='store_true')

  parser.add_argument('instance_id')
  args = parser.parse_args()

  if args.debug:
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)

  bridge_int = 'br-int'

  nova = init_nova()  
  neutron = init_neutron()
   
  network_id, instance_path = get_instance_path(nova, neutron, args.instance_id)

  dhcp_path = get_dhcp_path(neutron, network_id)

  router_path, router_id = get_router(neutron, network_id)

  print
  print '== NETWORK PATH =='
  print
  
  print 'INSTANCE:'
# http://openstack.redhat.com/Networking_in_too_much_detail
  pindent('\n'.join(('\t'.join(a) for a in instance_path)), 2)
  print

  print 'DHCP:'
  pindent('\n'.join(('\t'.join(a) for a in dhcp_path)), 2)
  print

  print 'L3 ROUTER (%s):' % router_id
  pindent('\n'.join(('\t'.join(a) for a in router_path)), 2)
  print
